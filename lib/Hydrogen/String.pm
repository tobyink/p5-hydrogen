# This file was autogenerated.
use 5.008008;
use strict;
use warnings;
no warnings qw( void once );
use Hydrogen ();

package Hydrogen::String;

our $AUTHORITY = 'cpan:TOBYINK';
our $VERSION   = '0.001';

=head1 NAME

Hydrogen::String - a standard library for strings

=cut

=head1 FUNCTIONS

Each function expects a string scalar as its first argument.

=cut

use Exporter::Shiny qw(
    append
    chomp
    chop
    clear
    cmp
    cmpi
    contains
    contains_i
    ends_with
    ends_with_i
    eq
    eqi
    fc
    ge
    gei
    get
    gt
    gti
    inc
    lc
    le
    lei
    length
    lt
    lti
    match
    match_i
    ne
    nei
    prepend
    replace
    replace_globally
    reset
    set
    starts_with
    starts_with_i
    substr
    uc
);

=head2 C<< Hydrogen::String::append( $string, $tail ) >>

Additional arguments: B<< Str >>.

Appends another string to the end of the current string and updates the original value.

=cut

sub append {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "append", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for append: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for append: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    (
        $_[0] = do {
            my $shv_final_unchecked = $_[0] . $_[1];
            do {
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined($shv_final_unchecked) and do {
                        ref( \$shv_final_unchecked ) eq 'SCALAR'
                          or ref( \( my $val = $shv_final_unchecked ) ) eq
                          'SCALAR';
                    }
                  }
                  or Hydrogen::croak(
"Type check failed in delegated method: expected %s, got value %s",
                    "Str", $shv_final_unchecked
                  );
                $shv_final_unchecked;
            };
        }
    );
}

=head2 C<< Hydrogen::String::chomp( $string ) >>

Like C<chomp> from L<perlfunc>.

=cut

sub chomp {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for chomp; usage: "
          . "Hydrogen::String::chomp( \$string )" );
    1;
    my $shv_return = chomp( my $shv_tmp = $_[0] );
    ( $_[0] = $shv_tmp );
    $shv_return;
}

=head2 C<< Hydrogen::String::chop( $string ) >>

Like C<chop> from L<perlfunc>.

=cut

sub chop {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for chop; usage: "
          . "Hydrogen::String::chop( \$string )" );
    1;
    my $shv_return = chop( my $shv_tmp = $_[0] );
    ( $_[0] = $shv_tmp );
    $shv_return;
}

=head2 C<< Hydrogen::String::clear( $string ) >>

Sets the string to the empty string.

=cut

sub clear {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for clear; usage: "
          . "Hydrogen::String::clear( \$string )" );
    1;
    ( $_[0] = q() );
}

=head2 C<< Hydrogen::String::cmp( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< $string cmp $str >>.

=cut

sub cmp {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "cmp", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for cmp: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for cmp: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    $_[0] cmp $_[1];
}

=head2 C<< Hydrogen::String::cmpi( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< fc($string) cmp fc($str) >>. Uses C<lc> instead of C<fc> in versions of Perl older than 5.16.

=cut

sub cmpi {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "cmpi", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for cmpi: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for cmpi: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( $_[0] ) cmp CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::contains( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns true iff the string contains C<< $str >>.

=cut

sub contains {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "contains", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for contains: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for contains: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    index( $_[0], $_[1] ) != -1;
}

=head2 C<< Hydrogen::String::contains_i( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns true iff the string contains C<< $str >> case-insensitvely.

=cut

sub contains_i {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "contains_i", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for contains_i: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for contains_i: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    index( CORE::fc( $_[0] ), CORE::fc( $_[1] ) ) != -1;
}

=head2 C<< Hydrogen::String::ends_with( $string, $tail ) >>

Additional arguments: B<< Str >>.

Returns true iff the string ends with C<< $tail >>.

=cut

sub ends_with {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "ends_with", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ends_with: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ends_with: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    substr( $_[0], -length $_[1] ) eq $_[1];
}

=head2 C<< Hydrogen::String::ends_with_i( $string, $tail ) >>

Additional arguments: B<< Str >>.

Returns true iff the string ends with C<< $tail >> case-insensitvely.

=cut

sub ends_with_i {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "ends_with_i", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ends_with_i: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ends_with_i: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( substr( $_[0], -length $_[1] ) ) eq CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::eq( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< $string eq $str >>.

=cut

sub eq {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "eq", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for eq: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for eq: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    $_[0] eq $_[1];
}

=head2 C<< Hydrogen::String::eqi( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< fc($string) eq fc($str) >>. Uses C<lc> instead of C<fc> in versions of Perl older than 5.16.

=cut

sub eqi {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "eqi", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for eqi: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for eqi: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( $_[0] ) eq CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::fc( $string ) >>

Returns C<< fc($string) >>.

=cut

sub fc {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for fc; usage: "
          . "Hydrogen::String::fc( \$string )" );
    CORE::fc( $_[0] );
}

=head2 C<< Hydrogen::String::ge( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< $string ge $str >>.

=cut

sub ge {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "ge", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ge: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ge: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    $_[0] ge $_[1];
}

=head2 C<< Hydrogen::String::gei( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< fc($string) ge fc($str) >>. Uses C<lc> instead of C<fc> in versions of Perl older than 5.16.

=cut

sub gei {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "gei", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for gei: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for gei: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( $_[0] ) ge CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::get( $string ) >>

Gets the current value of the string.

=cut

sub get {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for get; usage: "
          . "Hydrogen::String::get( \$string )" );
    $_[0];
}

=head2 C<< Hydrogen::String::gt( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< $string gt $str >>.

=cut

sub gt {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "gt", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for gt: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for gt: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    $_[0] gt $_[1];
}

=head2 C<< Hydrogen::String::gti( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< fc($string) gt fc($str) >>. Uses C<lc> instead of C<fc> in versions of Perl older than 5.16.

=cut

sub gti {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "gti", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for gti: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for gti: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( $_[0] ) gt CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::inc( $string ) >>

Performs C<< ++ >> on the string.

=cut

sub inc {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for inc; usage: "
          . "Hydrogen::String::inc( \$string )" );
    1;
    (
        $_[0] = do { my $shv_tmp = $_[0]; ++$shv_tmp }
    );
}

=head2 C<< Hydrogen::String::lc( $string ) >>

Returns C<< lc($string) >>.

=cut

sub lc {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for lc; usage: "
          . "Hydrogen::String::lc( \$string )" );
    lc( $_[0] );
}

=head2 C<< Hydrogen::String::le( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< $string le $str >>.

=cut

sub le {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "le", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for le: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for le: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    $_[0] le $_[1];
}

=head2 C<< Hydrogen::String::lei( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< fc($string) le fc($str) >>. Uses C<lc> instead of C<fc> in versions of Perl older than 5.16.

=cut

sub lei {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "lei", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for lei: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for lei: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( $_[0] ) le CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::length( $string ) >>

Like C<length> from L<perlfunc>.

=cut

sub length {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for length; usage: "
          . "Hydrogen::String::length( \$string )" );
    length( $_[0] );
}

=head2 C<< Hydrogen::String::lt( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< $string lt $str >>.

=cut

sub lt {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "lt", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for lt: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for lt: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    $_[0] lt $_[1];
}

=head2 C<< Hydrogen::String::lti( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< fc($string) lt fc($str) >>. Uses C<lc> instead of C<fc> in versions of Perl older than 5.16.

=cut

sub lti {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "lti", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for lti: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for lti: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( $_[0] ) lt CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::match( $string, $regexp ) >>

Additional arguments: B<< Str|RegexpRef >>.

Returns true iff the string matches the regexp.

=cut

sub match {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "match", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for match: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str|RegexpRef)
        do {

            package Hydrogen::String::__SANDBOX__;
            (
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined( $_[1] ) and do {
                        ref( \$_[1] ) eq 'SCALAR'
                          or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
                    }
                  }
                  or (
                    do {

                        package Hydrogen::String::__SANDBOX__;
                        use Scalar::Util ();
                        use re           ();
                        ref( $_[1] ) && !!re::is_regexp( $_[1] )
                          or Scalar::Util::blessed( $_[1] )
                          && $_[1]->isa('Regexp');
                    }
                  )
            );
          }
          or Hydrogen::croak(
            "Type check failed in signature for match: %s should be %s",
            "\$_[1]", "Str|RegexpRef" );

        (@_);
    };
    $_[0] =~ /$_[1]/;
}

=head2 C<< Hydrogen::String::match_i( $string, $regexp ) >>

Additional arguments: B<< Str|RegexpRef >>.

Returns true iff the string matches the regexp case-insensitively.

=cut

sub match_i {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "match_i", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for match_i: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str|RegexpRef)
        do {

            package Hydrogen::String::__SANDBOX__;
            (
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined( $_[1] ) and do {
                        ref( \$_[1] ) eq 'SCALAR'
                          or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
                    }
                  }
                  or (
                    do {

                        package Hydrogen::String::__SANDBOX__;
                        use Scalar::Util ();
                        use re           ();
                        ref( $_[1] ) && !!re::is_regexp( $_[1] )
                          or Scalar::Util::blessed( $_[1] )
                          && $_[1]->isa('Regexp');
                    }
                  )
            );
          }
          or Hydrogen::croak(
            "Type check failed in signature for match_i: %s should be %s",
            "\$_[1]", "Str|RegexpRef" );

        (@_);
    };
    $_[0] =~ /$_[1]/i;
}

=head2 C<< Hydrogen::String::ne( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< $string ne $str >>.

=cut

sub ne {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "ne", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ne: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for ne: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    $_[0] ne $_[1];
}

=head2 C<< Hydrogen::String::nei( $string, $str ) >>

Additional arguments: B<< Str >>.

Returns C<< fc($string) ne fc($str) >>. Uses C<lc> instead of C<fc> in versions of Perl older than 5.16.

=cut

sub nei {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "nei", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for nei: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for nei: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    CORE::fc( $_[0] ) ne CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::prepend( $string, $head ) >>

Additional arguments: B<< Str >>.

Prepends another string to the start of the current string and updates the original value.

=cut

sub prepend {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "prepend", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for prepend: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for prepend: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    (
        $_[0] = do {
            my $shv_final_unchecked = $_[1] . $_[0];
            do {
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined($shv_final_unchecked) and do {
                        ref( \$shv_final_unchecked ) eq 'SCALAR'
                          or ref( \( my $val = $shv_final_unchecked ) ) eq
                          'SCALAR';
                    }
                  }
                  or Hydrogen::croak(
"Type check failed in delegated method: expected %s, got value %s",
                    "Str", $shv_final_unchecked
                  );
                $shv_final_unchecked;
            };
        }
    );
}

=head2 C<< Hydrogen::String::replace( $string, $regexp, $replacement ) >>

Additional arguments: B<< Str|RegexpRef >>, B<< Str|CodeRef >>.

Replaces the first regexp match within the string with the replacement string.

=cut

sub replace {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 3
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "replace", scalar(@_), "expected exactly 3 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for replace: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str|RegexpRef)
        do {

            package Hydrogen::String::__SANDBOX__;
            (
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined( $_[1] ) and do {
                        ref( \$_[1] ) eq 'SCALAR'
                          or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
                    }
                  }
                  or (
                    do {

                        package Hydrogen::String::__SANDBOX__;
                        use Scalar::Util ();
                        use re           ();
                        ref( $_[1] ) && !!re::is_regexp( $_[1] )
                          or Scalar::Util::blessed( $_[1] )
                          && $_[1]->isa('Regexp');
                    }
                  )
            );
          }
          or Hydrogen::croak(
            "Type check failed in signature for replace: %s should be %s",
            "\$_[1]", "Str|RegexpRef" );

        # Parameter $_[2] (type: Str|CodeRef)
        do {

            package Hydrogen::String::__SANDBOX__;
            (
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined( $_[2] ) and do {
                        ref( \$_[2] ) eq 'SCALAR'
                          or ref( \( my $val = $_[2] ) ) eq 'SCALAR';
                    }
                  }
                  or ( ref( $_[2] ) eq 'CODE' )
            );
          }
          or Hydrogen::croak(
            "Type check failed in signature for replace: %s should be %s",
            "\$_[2]", "Str|CodeRef" );

        (@_);
    };
    my $shv_tmp = $_[0];
    if ( ( ref( $_[2] ) eq 'CODE' ) ) {
        my $shv_callback = $_[2];
        $shv_tmp =~ s/$_[1]/$shv_callback->()/e;
    }
    else { $shv_tmp =~ s/$_[1]/$_[2]/ }
    (
        $_[0] = do {
            my $shv_final_unchecked = $shv_tmp;
            do {
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined($shv_final_unchecked) and do {
                        ref( \$shv_final_unchecked ) eq 'SCALAR'
                          or ref( \( my $val = $shv_final_unchecked ) ) eq
                          'SCALAR';
                    }
                  }
                  or Hydrogen::croak(
"Type check failed in delegated method: expected %s, got value %s",
                    "Str", $shv_final_unchecked
                  );
                $shv_final_unchecked;
            };
        }
    );
}

=head2 C<< Hydrogen::String::replace_globally( $string, $regexp, $replacement ) >>

Additional arguments: B<< Str|RegexpRef >>, B<< Str|CodeRef >>.

Replaces the all regexp matches within the string with the replacement string.

=cut

sub replace_globally {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 3
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "replace_globally", scalar(@_), "expected exactly 3 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
"Type check failed in signature for replace_globally: %s should be %s",
            "\$_[0]", "Str"
          );

        # Parameter $_[1] (type: Str|RegexpRef)
        do {

            package Hydrogen::String::__SANDBOX__;
            (
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined( $_[1] ) and do {
                        ref( \$_[1] ) eq 'SCALAR'
                          or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
                    }
                  }
                  or (
                    do {

                        package Hydrogen::String::__SANDBOX__;
                        use Scalar::Util ();
                        use re           ();
                        ref( $_[1] ) && !!re::is_regexp( $_[1] )
                          or Scalar::Util::blessed( $_[1] )
                          && $_[1]->isa('Regexp');
                    }
                  )
            );
          }
          or Hydrogen::croak(
"Type check failed in signature for replace_globally: %s should be %s",
            "\$_[1]", "Str|RegexpRef"
          );

        # Parameter $_[2] (type: Str|CodeRef)
        do {

            package Hydrogen::String::__SANDBOX__;
            (
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined( $_[2] ) and do {
                        ref( \$_[2] ) eq 'SCALAR'
                          or ref( \( my $val = $_[2] ) ) eq 'SCALAR';
                    }
                  }
                  or ( ref( $_[2] ) eq 'CODE' )
            );
          }
          or Hydrogen::croak(
"Type check failed in signature for replace_globally: %s should be %s",
            "\$_[2]", "Str|CodeRef"
          );

        (@_);
    };
    my $shv_tmp = $_[0];
    if ( ( ref( $_[2] ) eq 'CODE' ) ) {
        my $shv_callback = $_[2];
        $shv_tmp =~ s/$_[1]/$shv_callback->()/eg;
    }
    else { $shv_tmp =~ s/$_[1]/$_[2]/g }
    (
        $_[0] = do {
            my $shv_final_unchecked = $shv_tmp;
            do {
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined($shv_final_unchecked) and do {
                        ref( \$shv_final_unchecked ) eq 'SCALAR'
                          or ref( \( my $val = $shv_final_unchecked ) ) eq
                          'SCALAR';
                    }
                  }
                  or Hydrogen::croak(
"Type check failed in delegated method: expected %s, got value %s",
                    "Str", $shv_final_unchecked
                  );
                $shv_final_unchecked;
            };
        }
    );
}

=head2 C<< Hydrogen::String::reset( $string ) >>

Resets the original value to its default value, or an empty string if it has no default.

=cut

sub reset {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for reset; usage: "
          . "Hydrogen::String::reset( \$string )" );
    (
        $_[0] = do {
            my $shv_final_unchecked = q{};
            do {
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined($shv_final_unchecked) and do {
                        ref( \$shv_final_unchecked ) eq 'SCALAR'
                          or ref( \( my $val = $shv_final_unchecked ) ) eq
                          'SCALAR';
                    }
                  }
                  or Hydrogen::croak(
"Type check failed in delegated method: expected %s, got value %s",
                    "Str", $shv_final_unchecked
                  );
                $shv_final_unchecked;
            };
        }
    );
}

=head2 C<< Hydrogen::String::set( $string, $value ) >>

Additional arguments: B<< Str >>.

Sets the string to a new value.

=cut

sub set {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "set", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for set: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for set: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    (
        $_[0] = do {
            my $shv_final_unchecked = $_[1];
            do {
                do {

                    package Hydrogen::String::__SANDBOX__;
                    defined($shv_final_unchecked) and do {
                        ref( \$shv_final_unchecked ) eq 'SCALAR'
                          or ref( \( my $val = $shv_final_unchecked ) ) eq
                          'SCALAR';
                    }
                  }
                  or Hydrogen::croak(
"Type check failed in delegated method: expected %s, got value %s",
                    "Str", $shv_final_unchecked
                  );
                $shv_final_unchecked;
            };
        }
    );
}

=head2 C<< Hydrogen::String::starts_with( $string, $head ) >>

Additional arguments: B<< Str >>.

Returns true iff the string starts with C<< $head >>.

=cut

sub starts_with {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "starts_with", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for starts_with: %s should be %s",
            "\$_[0]", "Str" );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for starts_with: %s should be %s",
            "\$_[1]", "Str" );

        (@_);
    };
    substr( $_[0], 0, length $_[1] ) eq $_[1];
}

=head2 C<< Hydrogen::String::starts_with_i( $string, $head ) >>

Additional arguments: B<< Str >>.

Returns true iff the string starts with C<< $head >> case-insensitvely.

=cut

sub starts_with_i {

    package Hydrogen::String::__SANDBOX__;
    @_ = do {
        my ( %tmp, $tmp );

        @_ == 2
          or Hydrogen::croak(
            "Wrong number of parameters in signature for %s: got %d, %s",
            "starts_with_i", scalar(@_), "expected exactly 2 parameters" );

        # Parameter $_[0] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[0] ) and do {
                ref( \$_[0] ) eq 'SCALAR'
                  or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for starts_with_i: %s should be %s",
            "\$_[0]", "Str"
          );

        # Parameter $_[1] (type: Str)
        do {

            package Hydrogen::String::__SANDBOX__;
            defined( $_[1] ) and do {
                ref( \$_[1] ) eq 'SCALAR'
                  or ref( \( my $val = $_[1] ) ) eq 'SCALAR';
            }
          }
          or Hydrogen::croak(
            "Type check failed in signature for starts_with_i: %s should be %s",
            "\$_[1]", "Str"
          );

        (@_);
    };
    CORE::fc( substr( $_[0], 0, length $_[1] ) ) eq CORE::fc( $_[1] );
}

=head2 C<< Hydrogen::String::substr( $string, $start, $length?, $replacement? ) >>

Additional arguments: B<< Int >>, B<< Optional[Int] >>, B<< Optional[Str] >>.

Like C<substr> from L<perlfunc>, but is not an lvalue.

=cut

{
    my $__signature;

    sub substr {

        package Hydrogen::String::__SANDBOX__;
        $__signature ||= sub {
            my ( %tmp, $tmp );

            @_ >= 2 && @_ <= 4
              or Hydrogen::croak(
                "Wrong number of parameters in signature for %s: got %d, %s",
                "substr", scalar(@_), "expected exactly 2 parameters" );

            # Parameter $_[0] (type: Str)
            do {

                package Hydrogen::String::__SANDBOX__;
                defined( $_[0] ) and do {
                    ref( \$_[0] ) eq 'SCALAR'
                      or ref( \( my $val = $_[0] ) ) eq 'SCALAR';
                }
              }
              or Hydrogen::croak(
                "Type check failed in signature for substr: %s should be %s",
                "\$_[0]", "Str" );

            # Parameter $_[1] (type: Int)
            (
                do {
                    my $tmp = $_[1];
                    defined($tmp) and !ref($tmp) and $tmp =~ /\A-?[0-9]+\z/;
                }
              )
              or Hydrogen::croak(
                "Type check failed in signature for substr: %s should be %s",
                "\$_[1]", "Int" );

            # Parameter $_[2] (type: Optional[Int])
            $#_ >= 2
              or return (@_);
            (
                do {
                    my $tmp = $_[2];
                    defined($tmp) and !ref($tmp) and $tmp =~ /\A-?[0-9]+\z/;
                }
              )
              or Hydrogen::croak(
                "Type check failed in signature for substr: %s should be %s",
                "\$_[2]", "Optional[Int]" );

            # Parameter $_[3] (type: Optional[Str])
            $#_ >= 3
              or return (@_);
            do {

                package Hydrogen::String::__SANDBOX__;
                defined( $_[3] ) and do {
                    ref( \$_[3] ) eq 'SCALAR'
                      or ref( \( my $val = $_[3] ) ) eq 'SCALAR';
                }
              }
              or Hydrogen::croak(
                "Type check failed in signature for substr: %s should be %s",
                "\$_[3]", "Optional[Str]" );

            (@_);
        };
        @_ = &$__signature;
        if    ( ( @_ - 1 ) == 1 ) { substr( $_[0], $_[1] ) }
        elsif ( ( @_ - 1 ) == 2 ) { substr( $_[0], $_[1], $_[2] ) }
        elsif ( ( @_ - 1 ) == 3 ) {
            my $shv_tmp    = $_[0];
            my $shv_return = substr( $shv_tmp, $_[1], $_[2], $_[3] );
            (
                $_[0] = do {
                    my $shv_final_unchecked = $shv_tmp;
                    do {
                        do {

                            package Hydrogen::String::__SANDBOX__;
                            defined($shv_final_unchecked) and do {
                                ref( \$shv_final_unchecked ) eq 'SCALAR'
                                  or ref( \( my $val = $shv_final_unchecked ) )
                                  eq 'SCALAR';
                            }
                          }
                          or Hydrogen::croak(
"Type check failed in delegated method: expected %s, got value %s",
                            "Str", $shv_final_unchecked
                          );
                        $shv_final_unchecked;
                    };
                }
            );
            $shv_return;
        }
    }
}

=head2 C<< Hydrogen::String::uc( $string ) >>

Returns C<< uc($string) >>.

=cut

sub uc {

    package Hydrogen::String::__SANDBOX__;
    @_ == 1
      or Hydrogen::croak( "Wrong number of parameters for uc; usage: "
          . "Hydrogen::String::uc( \$string )" );
    uc( $_[0] );
}

1;

=head1 EXPORT

No functions are exported by this module by default. To import them all
(this is usually a bad idea), use:

    use Hydrogen::String -all;

To import a particular function, use:

    use Hydrogen::String 'chop';

To rename functions:

    use Hydrogen::String 'chop' => { -as => 'myfunc' };

See L<Exporter::Tiny::Manual::Importing> for more hints on importing.

=head1 BUGS

Please report any bugs to
L<http://github.com/tobyink/p5-hydrogen/issues>.

=head1 SEE ALSO

L<Hydrogen>, L<Sub::HandlesVia::HandlerLibrary::String>.

=head1 AUTHOR

Toby Inkster E<lt>tobyink@cpan.orgE<gt>.

=head1 COPYRIGHT AND LICENCE

This software is copyright (c) 2022 by Toby Inkster.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.


