use v5.12;
use strict;
use warnings;

use Module::Runtime qw( use_module );
use Sub::HandlesVia::CodeGenerator;
use Sub::HandlesVia::Handler;
use Types::Standard -types;

BEGIN {
	use strict;
	use warnings;

	package Hydrogen::CodeGenerator;
	use parent 'Sub::HandlesVia::CodeGenerator';

	sub class               { shift; };
	sub _handle_shiftself   { shift; };
	sub _function_for_croak { 'Hydrogen::croak'; };

	sub _build_generator_for_type_assertion {
		my $self = shift;
		return sub {
			require B;
			my ( $gen, $env, $type, $varname ) = @_;
			if ( $gen->coerce and $type->{uniq} == Types::Standard::Bool()->{uniq} ) {
				return sprintf '%s = !!%s;', $varname, $varname;
			}
			if ( $gen->coerce and $type->has_coercion ) {
				return sprintf 'do { my $coerced = %s; %s or %s("Type check failed after coercion in delegated method: expected %%s, got value %%s", %s, $coerced); $coerced };',
					$type->coercion->inline_coercion( $varname ), $type->inline_check( '$coerced' ), $self->_function_for_croak, B::perlstring( $type->display_name );
			}
			return sprintf 'do { %s or %s("Type check failed in delegated method: expected %%s, got value %%s", %s, %s); %s };',
				$type->inline_check( $varname ), $self->_function_for_croak, B::perlstring( $type->display_name ), $varname, $varname;
		};
	}

	sub _handle_sigcheck {
		my ( $self, $method_name, $handler, $env, $code, $state ) = @_;

		# If there's a proper signature for the method...
		#
		if ( @{ $handler->signature || [] } ) {
			
			# Generate code using Type::Params to check the signature.
			# We also need to close over the signature.
			#
			require Mite::Signature::Compiler;
			
			my $compiler = 'Mite::Signature::Compiler'->new_from_compile(
				positional => {
					package        => $self->target,
					subname        => $method_name,
					is_wrapper     => !!0,
					mite_signature => $self,
				},
				$state->{shifted_self}
					? @{ $handler->signature }
					: ( $self->isa, @{ $handler->signature } ),
			);
			
			my $sigcode = $compiler->coderef->code;
			$sigcode =~ s/^\s+|\s+$//gs;
			if ( $sigcode =~ /return/ ) {
				push @$code, sprintf '$__signature ||= %s;', $sigcode;
				push @$code, '@_ = &$__signature;';
				$env->{'$__signature'} = \0;
			}
			else {
				$sigcode =~ s/^sub/do/;
				push @$code, sprintf '@_ = %s;', $sigcode;
			}
			
			# As we've now inserted a signature check, we can stop worrying
			# about signature checks.
			#
			$state->{signature_check_needed} = 0;
		}
		# There is no proper signature, but there's still check the
		# arity of the method.
		#
		else {
			# What is the arity?
			#
			my $min_args = $handler->min_args || 0;
			my $max_args = $handler->max_args;
			
			my $plus = 1;
			if ( $state->{shifted_self} ) {
				$plus = 0;
			}
			
			# What usage message do we want to print if wrong arity?
			#
			my $usg = sprintf(
				'%s("Wrong number of parameters for %s; usage: ".%s)',
				$self->_function_for_croak,
				$method_name,
				B::perlstring( $self->generate_usage_string( $method_name, $handler->usage ) ),
			);
			
			# Insert the check into the code.
			#
			if (defined $min_args and defined $max_args and $min_args==$max_args) {
				push @$code, sprintf('@_==%d or %s;', $min_args + $plus, $usg);
			}
			elsif (defined $min_args and defined $max_args) {
				push @$code, sprintf('(@_ >= %d and @_ <= %d) or %s;', $min_args + $plus, $max_args + $plus, $usg);
			}
			elsif (defined $min_args and $min_args > 0) {
				push @$code, sprintf('@_ >= %d or %s;', $min_args + $plus, $usg);
			}
			
			# We are still lacking a proper signature check though, so note
			# that in the state. The information can be used by
			# additional_validation coderefs.
			#
			$state->{signature_check_needed} = !!1;
		}
		
		return $self;
	}

	1;
};

my @types = qw(
	Array
	Bool
	Code
	Counter
	Hash
	Number
	Scalar
	String
);

my %default = (
	Array   => '[]',
	Bool    => '!!0',
	Code    => 'sub {}',
	Counter => '0',
	Hash    => '{}',
	Number  => '0',
	Scalar  => 'undef',
	String  => 'q{}',
);

my $target_namespace = 'Hydrogen';

for my $type ( my @xyz = ( @types, qw( Array* Hash* Code* ) ) ) {

	my $prototyped = !!0;
	if ( $type =~ /^(.+)\*/ ) {
		$type = $1;
		$prototyped = !!1;
	}

	my $lctype = lc $type;
	my $target_module = sprintf '%s::%s', $target_namespace, $type;
	if ( $type =~ /Array|Hash|Code/ and not $prototyped ) {
		$target_module .= 'Ref';
	}
	my $source_module = use_module( 'Sub::HandlesVia::HandlerLibrary::' . $type );

	my @funcs = do { no strict 'refs'; sort @{"$source_module\::METHODS"} };

	local $Type::Tiny::AvoidCallbacks = 1;
	local $Type::Tiny::SafePackage = "package $target_module\::__SANDBOX__;";

	my $example_var = "\$$lctype";
	if ( $prototyped ) {
		$example_var = {
			Array => '@array',
			Code  => '{ CODE }',
			Hash  => '%hash',
		}->{$type};
	}

	( my $filename = $target_module ) =~ s{::}{/}g;
	$filename = "lib/$filename.pm";

	open my $fh, '>', $filename;

	say $fh "# This file was autogenerated.";
	say $fh "use 5.008008;";
	say $fh "use strict;";
	say $fh "use warnings;";
	say $fh "use $target_namespace ();\n";
	
	say $fh "package $target_module;\n";
	say $fh "our \$AUTHORITY = 'cpan:TOBYINK';";
	say $fh "our \$VERSION   = '0.001';\n";
	
	say $fh "=head1 NAME\n";
	{
		my $nicetype = {
			Array   => $prototyped ? 'arrays' : 'arrayrefs',
			Bool    => 'booleans',
			Code    => $prototyped ? 'code blocks' : 'coderefs',
			Counter => 'integer counters',
			Hash    => $prototyped ? 'hashes' : 'hashrefs',
			Number  => 'numbers',
			Scalar  => 'scalars',
			String  => 'strings',
		}->{$type};
		say $fh "$target_module - a standard library for $nicetype\n";
		say $fh "=cut\n";
	}

	say $fh "=head1 FUNCTIONS\n";
	{
		my $nicetype = {
			Array   => $prototyped ? 'an array' : 'a reference to an array',
			Bool    => 'a scalar which will be treated as a boolean',
			Code    => $prototyped ? 'a code block' : 'a reference to a sub',
			Counter => 'an integer',
			Hash    => $prototyped ? 'a hash' : 'a reference to a hash',
			Number  => 'a numeric scalar',
			Scalar  => 'a scalar',
			String  => 'a string scalar',
		}->{$type};
		say $fh "Each function expects $nicetype as its first argument.\n";
		if ( $prototyped ) {
			say $fh "The functions use prototypes, so you don't have to pass a reference.\n";
		}
	}
	say $fh "=cut\n";

	say $fh "use Exporter::Shiny qw(";
	say $fh "    $_" for @funcs;
	say $fh ");";
	say $fh "";
	
	my $setter = sub { my ($gen, $value) = @_; "( \$_[0] = $value )" };
	if ( $type eq 'Array' ) {
		$setter = sub {
			my ($gen, $value) = @_;
			if ( $value eq '[]' ) {
				return "( \@{ \$_[0] } = () )";
			}
			"( \@{ \$_[0] } = \@{ $value } )";
		};
	}
	elsif ( $type eq 'Hash' ) {
		$setter = sub {
			my ($gen, $value) = @_;
			if ( $value eq '{}' ) {
				return "( \%{ \$_[0] } = () )";
			}
			"( %{ \$_[0] } = %{ $value } )";
		};
	}

	my $gen = 'Hydrogen::CodeGenerator'->new(
		toolkit        => 'Hydrogen',
		target         => $target_module,
		attribute      => 'dummy',
		attribute_spec => {},
		isa            => {
			Hash    => HashRef,
			Array   => ArrayRef,
			Code    => CodeRef,
			String  => Str,
			Number  => Num,
			Counter => Int,
		}->{$type} || Any,
		coerce         => !!0,
		env            => {},
		sandboxing_package => undef,
		generator_for_slot => sub { my ($gen) = @_;         '$_[0]'               },
		generator_for_get  => sub { my ($gen) = @_;         '$_[0]'               },
		generator_for_set  => $setter,
		generator_for_self => sub { my ($gen) = @_;         '( my $__SELF__ = $_[0] )' },
		generator_for_usage_string => sub {
			my ( $gen, $method_name, $guts ) = @_;
			if ( $prototyped and $type eq 'Code' ) {
				if ( length $guts ) {
					return "$target_module\::$method_name \$$lctype $guts";
				}
				else {
					return "$target_module\::$method_name \$$lctype";
				}
			}
			else {
				if ( length $guts ) {
					return "$target_module\::$method_name( \$$lctype, $guts )";
				}
				else {
					return "$target_module\::$method_name( \$$lctype )";
				}
			}
		},
		generator_for_default => sub { $default{$type} },
	);

	for my $func ( @funcs ) {
		next if $func eq 'execute_method';
		next if $func eq 'scalar_reference';

		my $h = 'Sub::HandlesVia::Handler'->lookup( $func, $type );

		if ( $prototyped and $type eq 'Code' ) {
			if ( $h->usage ) {
				printf $fh "=head2 C<< %s::%s %s %s >>\n\n", $target_module, $func, $example_var, $h->usage;
			}
			elsif ( $h->args == 0 ) {
				printf $fh "=head2 C<< %s::%s %s >>\n\n", $target_module, $func, $example_var;
			}
			else {
				printf $fh "=head2 C<< %s::%s >>\n\n", $target_module, $func;
			}
		}
		else {
			if ( $h->usage ) {
				printf $fh "=head2 C<< %s::%s( %s, %s ) >>\n\n", $target_module, $func, $example_var, $h->usage;
			}
			elsif ( $h->args == 0 ) {
				printf $fh "=head2 C<< %s::%s( %s ) >>\n\n", $target_module, $func, $example_var;
			}
			else {
				printf $fh "=head2 C<< %s::%s >>\n\n", $target_module, $func;
			}
		}

		if ( $h->signature and @{ $h->signature } ) {
			printf $fh "Additional arguments: %s.\n\n",
			join q[, ], map sprintf( 'B<< %s >>', $_->display_name ), @{ $h->signature };
		}

		if ( $h->documentation ) {
			my $docs = $h->documentation;
			$docs =~ s/\$object->attr/$example_var/g;
			$docs =~ s/Chainable method/Function/;
			$docs =~ s/attribute/original value/;
			print $fh $docs, "\n\n";
		}

		my $proto = '';
		if ( $prototyped and defined $h->max_args and $h->max_args == 0 ) {
			$proto = {
				Array => ' (\@)',
				Code  => ' (&)',
				Hash  => ' (\%)',
			}->{$type};
		}
		elsif ( $prototyped ) {
			my ( $required, $optional ) = ( '', ';@' );
			if ( defined $h->min_args ) {
				$required = '$' x $h->min_args;
				$optional = defined( $h->max_args ) ? ( '$' x ( $h->max_args - $h->min_args ) ) : '@';
				$optional = ";$optional" if $optional;
			}
			$proto = {
				Array => ' (\@' . $required . $optional . ')',
				Code  => ' (&' . $required . $optional . ')',
				Hash  => ' (\%' . $required . $optional . ')',
			}->{$type};
		}

		say $fh "=cut\n";

		my $eval = $gen->_generate_ec_args_for_handler( $func, $h );
		my $code = join "\n", @{$eval->{source}};
		$code =~ s/sub/sub $func$proto/xs;
		if ( $eval->{environment}{'$__signature'} ) {
			$code = "{ my \$__signature; $code }";
		}
		if (eval { require Perl::Tidy }) {
			my $tidy = '';
			Perl::Tidy::perltidy(
				source      => \$code,
				destination => \$tidy,
			);
			$code = $tidy;
		}
		say $fh $code;
	}

	say $fh "1;\n";

	say $fh <<"FOOTER";
=head1 EXPORT

No functions are exported by this module by default. To import them all
(this is usually a bad idea), use:

    use $target_module -all;

To import a particular function, use:

    use $target_module '@{[ $funcs[2] // $funcs[0] ]}';

To rename functions:

    use $target_module '@{[ $funcs[2] // $funcs[0] ]}' => { -as => 'myfunc' };

See L<Exporter::Tiny::Manual::Importing> for more hints on importing.

=head1 BUGS

Please report any bugs to
L<http://github.com/tobyink/p5-hydrogen/issues>.

=head1 SEE ALSO

L<Hydrogen>, L<$source_module>.

=head1 AUTHOR

Toby Inkster E<lt>tobyink\@cpan.orgE<gt>.

=head1 COPYRIGHT AND LICENCE

This software is copyright (c) 2022 by Toby Inkster.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=head1 DISCLAIMER OF WARRANTIES

THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

FOOTER

}

